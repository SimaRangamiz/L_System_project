import matplotlib.pyplot as plt
import math

def l_system(axiom, rules, depth):
    """
    Generates the result of an L-system by iteratively applying rules to the axiom.

    Parameters:
    - axiom (str): The initial string representing the starting state of the L-system.
    - rules (dict): A dictionary where keys are characters in the axiom, and values are their replacement strings.
    - depth (int): The number of iterations to apply the rules.

    Returns:
    - str: The final string after applying the rules for the specified number of iterations.
    """
    result = axiom
    for i in range(depth):
        next_result = ""
        for char in result:
            next_result += rules.get(char, char)
        result = next_result
    return result

def to_radians(angle):
    """
    Converts an angle from degrees to radians.

    Parameters:
    - angle (float): The angle in degrees.

    Returns:
    - float: The angle converted to radians.
    """
    return angle * math.pi / 180

def draw_l_system(instructions, angle):
    """
    Draws the L-system based on the provided instructions and angle.

    Parameters:
    - instructions (str): The sequence of commands generated by the L-system.
    - angle (float): The turning angle (in degrees) for '+' and '-' commands.

    Returns:
    - tuple: 
        - coords (list of tuples): A list of (x, y) coordinates representing the path.
        - colors (list of str): A list of color codes for each segment of the path.
    """
    # Initialize starting position, direction, and a stack for saving/restoring states.
    x, y = 0, 0  
    direction = 0  # Start with a 0 degree angle.
    stack = []  
    coords = [(x, y)]  
    colors = []  # List to store the colors of each segment.
    
    # Define a color palette for the segments.
    color_palette = ["#DA70D6", "#9932CC"]
    color_index = 0  # Initialize color index.

    for command in instructions:
        if command == "F":  # Move forward
            new_x = x + math.cos(to_radians(direction))
            new_y = y + math.sin(to_radians(direction))
            coords.append((new_x, new_y))  # Append the new coordinates.
            colors.append(color_palette[color_index])  # Append the color for the segment.
            color_index = (color_index + 1) % len(color_palette)  # Alternate between colors.
            x, y = new_x, new_y  # Update the current position.
            
        elif command == "+":  # Turn right.
            direction += angle
        elif command == "-":  # Turn left.
            direction -= angle
        elif command == "[":  # Save current state (position and direction).
            stack.append((x, y, direction))
        elif command == "]":  # Restore previous state.
            x, y, direction = stack.pop()
            coords.append((x, y))  # Append the restored position.
            colors.append(colors[-1])  # Keep the same color for the restored segment.

    return coords, colors

# Define the initial axiom and production rules
axiom = "F-F-F-F-F-F"
rules = {
    "F": "cF-F-F++dFF+F-F"  
}
depth = 4  # Number of iterations for rule application
angle = 72  # Turning angle in degrees

# Generate the L-system instructions based on axiom and rules.
instructions = l_system(axiom, rules, depth)

# Convert instructions into coordinates and colors
coords, colors = draw_l_system(instructions, angle)
x_coords, y_coords = zip(*coords)

# Set up the plot and visualize the L-system.
plt.figure(figsize=(8, 8))
for i in range(1, len(x_coords)):
    plt.plot(x_coords[i-1:i+1], y_coords[i-1:i+1], color=colors[i-1], linewidth=0.8)

# Adjust the plot limits to zoom in/out and center the L-system.
plt.xlim(min(x_coords)-1, max(x_coords)+1) 
plt.ylim(min(y_coords)-1, max(y_coords)+1)  

plt.gca().set_aspect('equal', adjustable='box')
plt.axis("off") # Turn off axes for a cleaner visual representation.
plt.show()

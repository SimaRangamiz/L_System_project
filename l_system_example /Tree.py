import matplotlib.pyplot as plt
import math
import random

def l_system(axiom, rules, depth):
    """
    Generates the result of an L-system by iteratively applying rules to the axiom.

    Parameters:
    - axiom (str): The initial string representing the starting state of the L-system.
    - rules (dict): A dictionary where keys are characters in the axiom, and values are their replacement strings.
    - depth (int): The number of iterations to apply the rules.

    Returns:
    - str: The final string after applying the rules for the specified number of iterations.
    """
    result = axiom
    for i in range(depth):
        next_result = ""
        for char in result:
            next_result += rules.get(char, char)  # Apply rules to each character in the axiom
        result = next_result
    return result

def to_radians(angle):
    """
    Converts an angle from degrees to radians.

    Parameters:
    - angle (float): The angle in degrees.

    Returns:
    - float: The angle converted to radians.
    """
    return angle * math.pi / 180

def draw_l_system(instructions, angle):
    """
    Draws the L-system based on the provided instructions and angle.

    Parameters:
    - instructions (str): The sequence of commands generated by the L-system.
    - angle (float): The turning angle (in degrees) for '+' and '-' commands.

    Returns:
    - tuple: 
        - coords (list of tuples): A list of (x, y) coordinates representing the path.
        - colors (list of str): A list of color codes for each segment of the path.
    """
    # Initialize starting position, direction, and a stack for saving/restoring states.
    x, y = 0, 0
    direction = 90  # Start facing upwards (90 degrees)
    stack = []
    coords = [(x, y)]  # Initial position
    colors = []  # List to store the colors for each segment

    # Define a list of colors for the segments.
    color_list = [
        "#8B4513",  
        "#D2691E",  
        "#FF6347",  
        "#FF8C00",  
        "#FFD700",  
        "#FF4500",  
        "#B22222"   
    ]

    # Iterate over each command in the L-system's instructions.
    for command in instructions:
        if command == "F":  # Move forward
            new_x = x + math.cos(to_radians(direction))
            new_y = y + math.sin(to_radians(direction))
            coords.append((new_x, new_y))
            x, y = new_x, new_y
         
            colors.append(random.choice(color_list))  # Assign a random color for the segment
            
        elif command == "+":  # Turn right
            direction += angle
        elif command == "-":  # Turn left
            direction -= angle
        elif command == "[":  # Save current state (position and direction)
            stack.append((x, y, direction))
        elif command == "]":  # Restore previous state
            x, y, direction = stack.pop()
            coords.append((x, y))
            colors.append(random.choice(color_list))  # Assign a random color for the segment

    return coords, colors

# Define the initial axiom and production rules.
axiom = "X"
rules = {
    "Y": "[+X]",  
    "F": "FFF",  
    "X": "F[-FX][+Y][FFY[--FX][FX][++FX]]FFYF[+FFXX]"  
}
depth = 5  # Number of iterations to apply the rules.
angle = 16.5  # Turning angle in degrees.

# Generate the L-system instructions based on axiom and rules.
instructions = l_system(axiom, rules, depth)

# Convert instructions into coordinates and colors.
coords, colors = draw_l_system(instructions, angle)
x_coords, y_coords = zip(*coords)

# Set up the plot and visualize the L-system.
plt.figure(figsize=(8, 8))  
for i in range(1, len(x_coords)):
    plt.plot(x_coords[i-1:i+1], y_coords[i-1:i+1], color=colors[i-1], linewidth=0.8)  

# Adjust the plot limits to zoom in/out and center the L-system.
plt.xlim(min(x_coords) - 10, max(x_coords) + 10)
plt.ylim(min(y_coords) - 10, max(y_coords) + 10)

plt.gca().set_aspect('equal', adjustable='box')
plt.axis("off") # Turn off axes for a cleaner visual representation.
plt.show()
